#!/usr/bin/env python


import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    open(os.path.join(partial_path, "__init__.py"), "w").write("\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "w") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('icarus/parse/events/events.py', "\nimport logging as log\nfrom xml.etree.ElementTree import iterparse\nfrom icarus.parse.events.network import Network\nfrom icarus.parse.events.population import Population\nfrom icarus.util.file import multiopen, exists\nfrom icarus.util.general import defaultdict\n\n\ndef hhmmss(secs):\n    hh = secs // 3600\n    secs -= hh * 3600\n    mm = secs // 60\n    secs -= mm * 60\n    ss = secs\n    return f'{str(hh).zfill(2)}:{str(mm).zfill(2)}:{str(ss).zfill(2)}'\n\n\n\nclass Events:\n    def __init__(self, database):\n        self.database = database\n\n    def create_tables(self):\n        self.database.drop_table('output_agents', 'output_activities', 'output_legs')\n        self.database.cursor.execute('''\n            CREATE TABLE output_agents (\n                agent_id MEDIUMINT UNSIGNED,\n                plan_size TINYINT UNSIGNED,\n                exposure FLOAT\n            );  ''')\n        self.database.cursor.execute('''\n            CREATE TABLE output_activities (\n                agent_id MEDIUMINT UNSIGNED,\n                agent_idx TINYINT UNSINGED,\n                type VARCHAR(255),\n                start MEDIUMINT UNISGNED,\n                end MEDIUMINT UNSIGNED,\n                duration MEDIUMINT UNSIGNED,\n                exposure FLOAT\n            );  ''')\n        self.database.cursor.execute('''\n            CREATE TABLE output_legs (\n                agent_id MEDIUMINT UNSIGNED,\n                agent_idx MEDIUMINT UNSIGNED,\n                mode VARCHAR(255),\n                start MEDIUMINT UNISGNED,\n                end MEDIUMINT UNSIGNED,\n                duration MEDIUMINT UNSIGNED,\n                exposure FLOAT\n            );  ''')\n\n    \n    def create_indexes(self):\n        query = 'CREATE INDEX output_agents_agent ON output_agents(agent_id);'\n        self.database.cursor.execute(query)\n        query = 'CREATE INDEX output_activities_agent ON output_activities(agent_id, agent_idx);'\n        self.database.cursor.execute(query)\n        query = 'CREATE INDEX output_legs_agent ON output_legs(agent_id, agent_idx);'\n        self.database.cursor.execute(query)\n\n\n    def ready(self, eventspath, planspath):\n        ready = True\n        tables = ('temperatures', 'links', 'nodes', 'centroids', )\n        present = self.database.table_exists(*tables)\n        if len(present) < len(tables):\n            missing = ', '.join(set(tables) - set(present))\n            log.info(f'Could not find tables {missing} in database.')\n            ready = False\n        if not exists(planspath):\n            log.info(f'Could not find file {planspath} in run files.')\n            ready = False\n        if not exists(eventspath):\n            log.info(f'Could not find file {eventspath} in run files.')\n            ready = False\n        return ready\n\n    \n    def complete(self):\n        tables = ('output_agents', 'output_activities', 'output_legs')\n        exists = self.database.table_exists(*tables)\n        if len(exists):\n            present = ', '.join(exists)\n            log.info(f'Found tables {present} already in database.')\n        return len(exists) > 0\n\n\n    def parse(self, planspath, eventspath):\n        eventsfile = multiopen(eventspath, mode='rb')\n        events = iter(iterparse(eventsfile, events=('start', 'end')))\n        evt, root = next(events)\n\n        log.info('Loading and building network for exposure analysis.')\n        network = Network(self.database)\n        network.load_network(planspath)\n        population = Population(network)\n\n        count = 0\n        time = 14400\n        n = 14400\n\n        log.info('Iterating over events file and calculating exposure.')\n        for evt, elem in events:\n            if evt == 'end' and elem.tag == 'event':\n                time = int(float(elem.get('time')))\n                population.parse_event(elem)\n\n            count += 1\n            if time >= n:\n                log.info(f'Simulation analysis at {hhmmss(time)} with {count} '\n                    'events processed.')\n                n += 3600\n            if count % 100000 == 0:\n                root.clear()\n        \n        log.info('Closing events file and completing parsing.')\n        root.clear()\n        eventsfile.close()\n\n        log.info('Processing and analyzing results.')\n        population.filter_agents(lambda agent: str(agent.id).isdigit())\n        population.cleanup(time)\n\n        log.info('Dumping results to database.')\n        agents = population.export_agents()\n        activities = population.export_activities()\n        legs = population.export_legs()\n        self.create_tables()\n        self.database.insert_values('output_agents', agents, 3)\n        self.database.insert_values('output_activities', activities, 7)\n        self.database.insert_values('output_legs', legs, 7)\n        self.create_indexes()\n        self.database.connection.commit()")
    __stickytape_write_module('icarus/parse/events/network.py', "\n\n# from __future__ import annotations\n\nimport logging as log\nfrom typing import List\nfrom xml.etree.ElementTree import iterparse, tostring\n\nfrom icarus.parse.events.types import LegMode\nfrom icarus.parse.events.agent import Agent\n\nfrom icarus.util.general import defaultdict, counter\nfrom icarus.util.file import multiopen\n\n\nclass Route:\n    __slots__= ('start_link', 'end_link', 'path', 'distance', 'mode')\n\n    def __init__(self, start_link, end_link, path, \n            distance: float, mode: LegMode):\n        self.start_link = start_link\n        self.end_link = end_link\n        self.path = path\n        self.distance = distance\n        self.mode = mode\n\n    def get_exposure(self, start, stop):  \n        exposure = 0\n        duration = stop - start\n        time = start\n        distance = sum(link.length for link in self.path)\n        for link in self.path:\n            elapse = duration * link.length / distance\n            exp = link.get_exposure(time, time + elapse)\n            exposure += exp\n            time += elapse\n        return exposure\n\n\n\nclass Link:\n    __slots__ = ('id', 'x', 'y', 'length', 'freespeed', 'centroid')\n\n    def __init__(self, uuid: str, x: float, y:float, length: float, \n            freespeed: float, centroid):\n        self.id = uuid\n        self.x = x\n        self.y = y\n        self.length = length\n        self.freespeed = freespeed\n        self.centroid = centroid\n    \n\n    def get_temperature(self, time):\n        return self.centroid.get_temperature(time)\n\n\n    def get_exposure(self, start, stop):\n        return self.centroid.get_exposure(start, stop)\n\n\n    def entry(self):\n        return (self.x, self.y, self.x, self.y)\n\n\n\nclass Centroid:\n    __slots__ = ('id', 'x', 'y', 'temperatures')\n\n    def __init__(self, uuid, x, y, temperatures):\n        self.id = uuid\n        self.x = x\n        self.y = y\n        self.temperatures = temperatures\n\n\n    def get_temperature(self, time):\n        steps = len(self.temperatures)\n        step = int(time / 86400 * steps) % steps\n        return self.temperatures[step]\n\n\n    def get_exposure(self, start, stop):\n        steps = len(self.temperatures)\n        step_size = int(86400 / steps)\n        start_step = int(start / 86400 * steps)\n        stop_step = int(stop / 86400 * steps)\n        exposure = 0\n        if start_step == stop_step:\n            exposure = (stop - start) * self.temperatures[start_step % steps]\n        else:\n            exposure = ((start_step + 1) * step_size - start) * \\\n                self.temperatures[start_step % steps]\n            for step in range(start_step + 1, stop_step):\n                exposure += step_size * self.temperatures[step % steps]\n            exposure += (stop - stop_step * step_size) * \\\n                self.temperatures[stop_step % steps]\n        return exposure\n\n\n\nclass Network:\n    def __init__(self, database):\n        self.database = database\n        self.temperatures = defaultdict(lambda x: [])\n        self.agents = {}\n        self.links = {}\n        self.centroids = {}\n\n\n    def fetch_temperatures(self):\n        self.database.cursor.execute('''\n            SELECT\n                temperature_id,\n                temperature_idx,\n                temperature\n            FROM temperatures\n            ORDER BY\n                temperature_id,\n                temperature_idx;  ''')\n        return self.database.cursor.fetchall()\n\n\n    def fetch_links(self):\n        self.database.cursor.execute('''\n            SELECT\n                links.link_id,\n                links.length,\n                links.freespeed,\n                links.modes,\n                nodes.point,\n                nodes.centroid_id\n            FROM links\n            INNER JOIN nodes\n            ON links.source_node = nodes.node_id; ''')\n        return self.database.cursor.fetchall()\n\n    \n    def fetch_centroids(self):\n        self.database.cursor.execute('''\n            SELECT\n                centroid_id,\n                temperature_id,\n                center\n            FROM centroids; ''')\n        return self.database.cursor.fetchall()\n\n\n    def get_agent(self, agent_id):\n        agent = None\n        if agent_id in self.agents:\n            agent = self.agents[agent_id]\n        else:\n            agent = Agent(agent_id)\n            self.agents[agent_id] = agent\n        return agent\n\n    \n    def load_routes(self, planspath):\n        routes = []\n        plansfile = multiopen(planspath, mode='rb')\n        plans = iter(iterparse(plansfile, events=('start', 'end')))\n        evt, root = next(plans)\n\n        agent = None\n        selected = False\n        mode = None\n        count = 0\n        n = 1\n\n        for evt, elem in plans:\n            if evt == 'start':\n                if elem.tag == 'person':\n                    agent = elem.get('id')\n                elif elem.tag == 'plan':\n                    selected = elem.get('selected') == 'yes'\n                elif elem.tag == 'leg':\n                    mode = elem.get('mode')\n            elif evt == 'end':\n                if elem.tag == 'route' and selected:\n                    vehicle = elem.get('vehicleRefId')\n                    kind = elem.get('type')\n                    if vehicle == 'null' and kind == 'links':\n                        start = elem.get('start_link')\n                        end = elem.get('end_link')\n                        distance = float(elem.get('distance'))\n                        path = (self.links[link] for link in elem.text.split(' '))\n                        uuid = f'{mode}-{start}-{end}'\n                        route = Route(self.links[start], self.links[end], \n                            tuple(path), distance, LegMode(mode))\n                        self.get_agent(agent).routes[uuid] = route\n                elif elem.tag == 'person':\n                    count += 1\n                    if count % 10000 == 0:\n                        root.clear()\n                    if count == n:\n                        log.info(f'Processed plan {count}.')\n                        n <<= 1\n\n        if count != (n >> 1):\n            log.info(f'Processed plan {count}.')\n        plansfile.close()\n\n        return routes\n\n    \n    def load_network(self, planspath):\n        log.info('Fetching network temperatures from database.')\n        temperatures = counter(self.fetch_temperatures(), 'Loading temperature %s.')\n\n        log.info('Loading network temperatures.')\n        for uuid, _, temperature in temperatures:\n            self.temperatures[uuid].append(temperature)\n        self.temperatures.lock()\n        \n        log.info('Fetching network centroids from database.')\n        centroids = counter(self.fetch_centroids(), 'Loading centroid %s.')\n\n        log.info('Loading network centroids.')\n        for uuid, tempid, centroid in centroids:\n            x, y = map(float, centroid[7:-1].split(' '))\n            self.centroids[uuid] = Centroid(uuid, x, y, self.temperatures[tempid])\n\n        log.info('Fetching network links from database.')\n        links = counter(self.fetch_links(), 'Loading link %s.')\n\n        log.info('Loading netowrk links.')\n        for uuid, length, speed, _, point, centid in links:\n            x, y = map(float, point[7:-1].split(' '))\n            centroid = self.centroids[centid]\n            self.links[uuid] = Link(uuid, x, y, length, speed, centroid)\n\n        log.info('Loading network routes from output plans file.')\n        self.routes = self.load_routes(planspath)\n\n\n    def get_temperature(self, link, time):\n        return self.links[link].get_temperature(time)\n\n        \n    def get_exposure(self, link, start, stop):\n        return self.links[link].get_exposure(start, stop)\n")
    __stickytape_write_module('icarus/parse/events/types.py', '\nimport logging as log\nfrom enum import Enum\n\n\nclass VehicleMode(Enum):\n    NONE = None\n    BUS = \'bus\'\n    TRAM = \'tram\'\n    CAR = \'car\'\n    BIKE = \'bike\'\n    NETWALK = \'netwalk\'\n\n    @staticmethod\n    def parse(vehicle_id):\n        mode = None\n        flag = vehicle_id.split(\'_\')[-1].lower()\n        if flag.isdigit():\n            mode = VehicleMode.CAR\n        else:\n            try:\n                mode = VehicleMode(flag)\n            except:\n                raise RuntimeError(f\'Unexpected vehicle id format in "{vehicle_id};\'\n                    \'could not identify vehicle mode as bus, tram or car.\')\n        return mode\n\n    def outdoors(self):\n        return self in (self.BIKE, self.NETWALK)\n        \n\n\nclass LegMode(Enum):\n    NONE = None\n    BUS = \'bus\'\n    BIKE = \'bike\'\n    CAR = \'car\'\n    NETWALK = \'netwalk\'\n    WALK = \'walk\'\n    PT = \'pt\'\n    FAKEMODE = \'fakemode\'\n\n    def transit(self):\n        return self in (self.PT, self.WALK)\n\n    def artificial(self):\n        return self == self.FAKEMODE\n\n    def string(self):\n        string = None\n        if self.transit():\n            string = \'pt\'\n        elif self == self.NETWALK:\n            string = \'walk\'\n        else:\n            string = self.value\n        return string\n            \n\n\nclass ActivityType(Enum):\n    NONE = None\n    HOME = 0\n    WORKPLACE = 1\n    UNIVERSITY = 2\n    SCHOOL = 3\n    ESCORT = 4\n    SCHOOL_ESCPORT = 41\n    PURE_ESCORT = 411\n    RIDESHARE_ESCORT = 412\n    OTHER_ESCORT = 42\n    SHOPPING = 5\n    OTHER_MAINTENANCE = 6\n    EATING_OUT = 7\n    BREAKFAST = 71\n    LUNCH = 72\n    DINNER = 73\n    VISITING = 8\n    OTHER_DISCRETIONARY = 9\n    SPECIAL_EVENT = 10\n    WORK = 11\n    WORK_BUSINESS = 12\n    WORK_LUNCH = 13\n    WORK_OTHER = 14\n    WORK_RELATED = 15\n    ASU = 16\n\n    PT_INTERACTION = 100\n    FAKEACTIVITY = 101\n\n    @classmethod\n    def parse(self, name):\n        name = name.upper().replace(\' \', \'_\')\n        return getattr(self, name)\n\n\n    def transit(self):\n        return self == self.PT_INTERACTION\n\n    def artificial(self):\n        return self == self.FAKEACTIVITY')
    __stickytape_write_module('icarus/__init__.py', '')
    __stickytape_write_module('icarus/parse/__init__.py', '')
    __stickytape_write_module('icarus/parse/events/__init__.py', '')
    __stickytape_write_module('icarus/parse/events/agent.py', "\nimport logging as log\nfrom icarus.parse.events.types import ActivityType, LegMode\n\n\nclass Activity:\n    __slots__ = ('activity_type', 'start_time', 'active_time',\n            'end_time', 'exposure', 'link')\n    \n    def __init__(self, activity_type):\n        self.activity_type = activity_type\n        self.start_time = None\n        self.active_time = None\n        self.end_time = None\n        self.link = None\n        self.exposure = 0\n\n\n    def start(self, time, link):\n        self.start_time = time\n        self.active_time = time\n        self.link = link\n\n\n    def wait(self, time, temperature):\n        self.exposure += (time - self.active_time) * temperature\n        self.active_time = time\n\n    \n    def end(self, time):\n        self.end_time = time\n        self.active_time = None\n\n\nclass Leg:\n    __slots__ = ('mode', 'start_time', 'start_link', 'active_time', 'active_link',\n            'end_time', 'end_link','exposure')\n\n    def __init__(self, leg_mode):\n        self.mode = leg_mode\n        self.start_time = None\n        self.start_link = None\n        self.active_time = None\n        self.active_link = None\n        self.end_time = None\n        self.end_link = None\n        self.exposure = 0\n\n    \n    def start(self, time, link):\n        self.start_time = time\n        self.start_link = link\n        self.active_time = time\n        self.active_link = link\n\n    \n    def teleport(self, time, link):\n        self.exposure += self.start_link.get_exposure(self.active_time, time)\n        self.active_time = time\n        self.active_link = link\n\n    \n    def wait(self, time, temperature):\n        self.exposure += (time - self.active_time) * temperature\n        self.active_time = time\n\n\n    def travel(self, time, route):\n        self.exposure += route.get_exposure(self.active_time, time)\n        self.active_time = time\n        self.active_link = route.end_link\n\n    \n    def end(self, time, link):\n        self.end_time = time\n        self.end_link = link\n        self.active_time = None\n        self.active_link = None\n\n\n\nclass Agent:\n    __slots__ = ('id', 'activities', 'legs', 'routes', 'active_activity', \n            'active_leg')\n    \n    def __init__(self, uuid):\n        self.id = uuid\n        self.activities = []\n        self.legs = []\n        self.routes = {}\n\n        self.active_activity = None\n        self.active_leg = None\n\n\n    def exposure(self):\n        return sum(leg.exposure for leg in self.legs) + \\\n            sum(act.exposure for act in self.activities)\n\n\n    def size(self):\n        return len(self.legs) + len(self.activities)\n\n    \n    def export_activities(self):\n        activities = ((\n            self.id,\n            idx,\n            activity.activity_type.name.lower(),\n            activity.start_time,\n            activity.end_time,\n            activity.end_time - activity.start_time,\n            activity.exposure\n        ) for idx, activity in enumerate(self.activities))\n        return activities\n\n    \n    def export_legs(self):\n        legs =  ((\n            self.id,\n            idx,\n            leg.mode.string(),\n            leg.start_time,\n            leg.end_time,\n            leg.end_time - leg.start_time,\n            leg.exposure\n        ) for idx, leg in enumerate(self.legs))\n        return legs\n\n\n    def start_activity(self, time, activity_type, link):\n        transit = self.active_leg is not None and self.active_leg.mode.transit()\n\n        if activity_type.artificial():\n            pass\n        elif activity_type.transit():\n            if transit:\n                self.active_leg.teleport(time, link)\n            else:\n                RuntimeError('Unexpected transit activity outside of transit route.')\n        else:\n            if transit:\n                self.active_leg.end(time, link)\n                self.legs.append(self.active_leg)\n                self.active_leg = None\n            self.active_activity = Activity(activity_type)\n            self.active_activity.start(time, link)\n    \n\n    def end_activity(self, time, link=None):\n        if self.active_leg is not None:\n            if self.active_leg.mode.transit():\n                self.active_leg.teleport(time, link)\n        else:\n            if self.active_activity is None:\n                self.active_activity = Activity(ActivityType.HOME)\n                self.active_activity.start(14400, link)\n            self.active_activity.wait(time, 25.5)\n            self.active_activity.end(time)\n            self.activities.append(self.active_activity)\n            self.active_activity = None\n\n    \n    def depart(self, time, mode, link):\n        transit = self.active_leg is not None and self.active_leg.mode.transit()\n        artificial = self.active_leg is not None and self.active_leg.mode.artificial()\n\n        if artificial:\n            self.active_leg.mode = mode\n            self.active_leg.wait(time, 25.5)\n        elif transit:\n            self.active_leg.teleport(time, link)\n        else:\n            self.active_leg = Leg(mode)\n            self.active_leg.start(time, link)\n\n\n    def arrive(self, time, link):\n        if not self.active_leg.mode.artificial():\n            if self.active_leg.active_link != link:\n                mode = self.active_leg.mode.value\n                start = self.active_leg.active_link.id\n                end = link.id\n                uuid = f'{mode}-{start}-{end}'\n                if uuid in self.routes:\n                    self.active_leg.travel(time, self.routes[uuid])\n                else:\n                    self.active_leg.teleport(time, link)\n\n            if not self.active_leg.mode.transit():\n                self.active_leg.end(time, link)\n                self.legs.append(self.active_leg)\n                self.active_leg = None\n\n\n    def expose(self, exposure):\n        self.active_leg.exposure += exposure\n\n")
    __stickytape_write_module('icarus/util/general.py', '\nimport logging as log\n\n\ndef chunk(start, stop, chunk):\n    bins = zip(range(start, stop, chunk), \n        range(start+chunk, stop+chunk, chunk))\n    for low, high in bins:\n        yield low, high\n\n\ndef bins(iterable, binsize):\n    for idx in range(0, len(iterable), binsize):\n        yield iterable[idx : idx + binsize]\n\n\ndef counter(iterable, message, start=1, end=True):\n    n = 1\n    count = 0\n    for count, item in enumerate(iterable, start):\n        if count == n:\n            log.info(message % count)\n            n <<= 1\n        yield item\n    if count != n >> 1 and end:\n        log.info(message % count)\n\n\nclass defaultdict(dict):\n    def __init__(self, function):\n        self.function = function\n        self.locked = False\n\n    def __getitem__(self, item):\n        if item in self:\n            return super().__getitem__(item)\n        elif not self.locked:\n            value = self.function(item)\n            self[item] = value\n            return value\n        else:\n            raise KeyError\n    \n    def lock(self):\n        self.locked = True\n\n    def unlock(self):\n        self.locked = False\n\n')
    __stickytape_write_module('icarus/util/__init__.py', '')
    __stickytape_write_module('icarus/util/file.py', "\nimport gzip\nimport os\nimport sys\nimport tempfile\nimport subprocess\n\n\ndef multiopen(filepath, mode='rt', **kwargs):\n    if os.path.splitext(filepath)[1] == '.gz':\n        data = gzip.open(filepath, mode=mode, **kwargs)\n    else:\n        data = open(filepath, mode=mode, **kwargs)\n    return data\n\n\ndef touch(filepath, recurse=False):\n    os.makedirs(os.path.dirname(filepath), exist_ok=True)\n    with open(filepath, 'w'):\n        pass\n\n\ndef exists(filepath):\n    return os.path.exists(filepath)\n\n\ndef readable(filepath):\n    return os.access(filepath, os.R_OK)\n\n\ndef writable(self, filepath):\n    write = False\n    if exists(filepath):\n        if os.path.isfile(filepath):\n            write = os.access(filepath, os.W_OK)\n    else:\n        pdir = os.path.dirname(filepath)\n        if not pdir: \n            pdir = '.'\n        write = os.access(pdir, os.W_OK)\n    return write\n\n\ndef format_xml(source, target=None):\n    if target is None:\n        targetfile = tempfile.NamedTemporaryFile(suffix='xml', delete=False)\n        target = targetfile.name\n        targetfile.close()\n        subprocess.run(f'xmllint --format {source} > {target}', shell=True)\n        subprocess.run(('mv', target, source), shell=False)\n    else:\n        subprocess.run(f'xmllint --format {source} > {target}', shell=True)\n\n\ndef resource(self, package, resource, error=False):\n    res = None\n    try:\n        module = os.path.dirname(sys.modules[package].__file__)\n        return os.path.join(module, resource)\n    except Exception:\n        if error:\n            raise FileNotFoundError\n    return res\n")
    __stickytape_write_module('icarus/parse/events/population.py', "\nimport logging as log\nfrom xml.etree.ElementTree import tostring\nfrom icarus.util.general import defaultdict\nfrom icarus.parse.events.agent import Agent\nfrom icarus.parse.events.vehicle import Vehicle\nfrom icarus.parse.events.network import Network\nfrom icarus.parse.events.types import VehicleMode, ActivityType, LegMode\n\n\nclass Population:\n    def __init__(self, network):\n        self.network = network\n        self.agents = network.agents\n        self.vehicles = {}\n\n\n    def get_agent(self, agent_id):\n        agent = None\n        if agent_id in self.agents:\n            agent = self.agents[agent_id]\n        else:\n            agent = Agent(agent_id)\n            self.agents[agent_id] = agent\n        return agent\n\n\n    def get_vehicle(self, vehicle_id, time, link):\n        vehicle = None\n        if vehicle_id in self.vehicles:\n            vehicle = self.vehicles[vehicle_id]\n        else:\n            mode = VehicleMode.parse(vehicle_id)\n            temperature = 25.5 if not mode.outdoors() else None\n            vehicle = Vehicle(vehicle_id, mode, time, link, temperature)\n            self.vehicles[vehicle_id] = vehicle\n        return vehicle\n\n\n    def parse_event(self, event):\n        action = event.get('type')\n        time = int(float(event.get('time')))\n        agent = None\n\n        if action == 'TransitDriverStarts':\n            agent = self.get_agent(event.get('driverId'))\n\n        elif action == 'left link':\n            link = self.network.links[event.get('link')]\n            vehicle = self.get_vehicle(event.get('vehicle'), time, link)\n            vehicle.leave_link(time, link)\n            \n        elif action == 'entered link':\n            link = self.network.links[event.get('link')]\n            vehicle = self.get_vehicle(event.get('vehicle'),time, link)\n            vehicle.enter_link(time, link)\n\n        elif action == 'PersonEntersVehicle':\n            agent = self.get_agent(event.get('person'))\n            link = agent.active_leg.active_link\n            vehicle = self.get_vehicle(event.get('vehicle'), time, link)\n            vehicle.add_agent(time, agent)\n\n        elif action == 'PersonLeavesVehicle':\n            agent = self.get_agent(event.get('person'))\n            link = agent.active_leg.active_link\n            vehicle = self.get_vehicle(event.get('vehicle'), time, link)\n            vehicle.remove_agent(time, agent)\n\n        elif action == 'actstart':\n            link = self.network.links[event.get('link')]\n            agent = self.get_agent(event.get('person'))\n            activity_type = ActivityType.parse(event.get('actType'))\n            agent.start_activity(time, activity_type, link)\n\n        elif action == 'actend':\n            link = self.network.links[event.get('link')]\n            agent = self.get_agent(event.get('person'))\n            agent.end_activity(time, link)\n\n        elif action == 'departure':\n            link = self.network.links[event.get('link')]\n            agent = self.get_agent(event.get('person'))\n            mode = LegMode(event.get('legMode'))\n            agent.depart(time, mode, link)\n\n        elif action == 'arrival':\n            link = self.network.links[event.get('link')]\n            agent = self.get_agent(event.get('person'))\n            agent.arrive(time, link)\n\n        elif action == 'stuckAndAbort':\n            pass\n\n        else:\n            pass\n\n    \n    def export_agents(self):\n        for agent in self.agents.values():\n            yield (\n                agent.id,\n                agent.size(),\n                agent.exposure())\n    \n\n    def export_activities(self):\n        for agent in self.agents.values():\n            for activity in agent.export_activities():\n                yield activity\n\n    \n    def export_legs(self):\n        for agent in self.agents.values():\n            for leg in agent.export_legs():\n                yield leg\n\n    \n    def filter_agents(self, condition):\n        remove = set()\n        for agent in self.agents.values():\n            if not condition(agent):\n                remove.add(agent.id)\n        for uuid in remove:\n            del self.agents[uuid]\n\n\n    def cleanup(self, time):\n        for agent in self.agents.values():\n            if agent.active_activity is not None:\n                if agent.active_activity.activity_type == ActivityType.HOME:\n                    agent.end_activity(time)\n\n")
    __stickytape_write_module('icarus/parse/events/vehicle.py', "\n\nclass Vehicle:\n    __slots__ = ('id', 'mode', 'agents', 'exposure', 'temperature', 'link', 'time')\n\n    def __init__(self, uuid, mode, time, link, temperature=None):\n        self.id = uuid\n        self.mode = mode\n        self.agents = set()\n        self.exposure = 0\n        self.temperature = temperature\n        self.link = link\n        self.time = time\n\n\n    def enter_link(self, time, link):\n        self.link = link\n        self.time = time\n\n    \n    def leave_link(self, time, link):\n        if self.time is not None:\n            if self.temperature is None:\n                self.exposure += self.link.get_exposure(self.time, time)\n            else:\n                self.exposure += self.temperature * (time - self.time)\n        self.time = time\n        self.link = link\n\n\n    def add_agent(self, time, agent):\n        self.leave_link(time, self.link)\n        agent.expose(-self.exposure)\n        self.agents.add(agent)\n    \n\n    def remove_agent(self, time, agent):\n        self.leave_link(time, self.link)\n        agent.active_leg.active_link = self.link\n        agent.active_leg.active_time = self.time\n        agent.expose(self.exposure)\n        self.agents.remove(agent)\n        \n")
    __stickytape_write_module('icarus/util/config.py', '\nimport json\nimport re\nimport os\n\nimport logging as log\n\nfrom icarus.util.filesys import FilesysUtil\n\n\nclass ConfigUtil:\n    \'\'\'static class used to verify config to specs for runner\n\n    also includes some useful tools for handling config parameters\n    \'\'\'\n    types = {\'str\': str, \'int\': int, \'bool\': bool, \'dict\': dict,\n        \'list\': list, \'float\': float, \'null\': None}\n\n\n    @classmethod\n    def load_config(self, filepath):\n        \'load a config file; catches file and JSON errors\'\n\n        config = None\n        try:\n            with open(filepath) as handle:\n                config =  json.load(handle)\n        except FileNotFoundError as err:\n            log.exception(f\'Config file "{filepath}" does not exist; \'\n                \'terminating model run.\')\n            raise err\n        except json.JSONDecodeError as err:\n            log.exception(f\'Config file "{filepath}" is not valid json; \'\n                \'terminating model run.\')\n            raise err\n        return config\n        \n\n    @classmethod\n    def load_specs(self, filepath):\n        \'load a config file; catches file and JSON errors\'\n\n        specs = None\n        try:\n            with open(filepath) as handle:\n                specs = json.load(handle)\n        except FileNotFoundError as err:\n            log.exception(f\'Specs file "{filepath}" does not exist; \'\n                \'terminating model run.\')\n            raise err\n        except json.JSONDecodeError as err:\n            log.exception(f\'Specs file "{filepath}" is not valid json; \'\n                \'terminating model run.\')\n            raise err\n        return specs\n\n\n    @classmethod\n    def verify_config(self, specs, config, name=\'\'):\n        \'\'\'recursively validates a a configuration dict againast a \n        specifications dict\n\n        Parameters\n        ----------\n        specs: dict\n            The dict representing a JSON specifications file.\n\n        config: dict\n            The dict representing a JSON configurations file; will be checked\n            against the specifications file.\n\n        name: str\n            The name of the specification property; used in error handling. This\n            is set recursively; the intial name is an empty string.\n\n        Returns\n        -------\n        config: dict\n            A new dict representing the JSON configuration file with any missing\n            default values added onto it.\n        \'\'\'\n\n        for attr in config.keys():\n            if attr not in specs.keys():\n                if type(attr) is int:\n                    path = f\'{name}[{attr}]\' if name != \'\' else attr\n                else:\n                    path = f\'{name}.{attr}\' if name != \'\' else attr\n                log.warning(f\'Config parameter "{path}" is not in model \'\n                    \'specifications; it will not impact model run.\')\n\n        for attr, spec in specs.items():\n            param = config[attr] if attr in config else None\n            if type(attr) is int:\n                path = f\'{name}[{attr}]\' if name != \'\' else attr\n            else:\n                path = f\'{name}.{attr}\' if name != \'\' else attr\n\n            if type(spec) is not dict:\n                config[attr] = spec\n            elif \'type\' in spec:\n                if param is None:\n                    if \'required\' not in spec or not spec[\'required\']:\n                        config[attr] = spec[\'default\'] if \'default\' in spec else None\n                    else:\n                        log.error(f\'Parameter "{attr}" is required.\')\n                        raise ValueError\n                elif spec[\'type\'] == \'dict\':\n                    if type(param) == dict:\n                        if \'min\' in spec and spec[\'min\'] > len(param):\n                            log.error(f\'Parameter "{path}" expected to have at least \'\n                                f\'{spec["min"]} elements but only found {len(param)}.\')\n                            raise ValueError\n                        if \'max\' in spec and spec[\'max\'] < len(param):\n                            log.error(f\'Parameter "{path}" expected to have at most \'\n                                f\'{spec["max"]} elements but found {len(param)}.\')\n                            raise ValueError\n                        if \'options\' in spec and not all(k in spec[\'options\'] \n                                for k in param.keys()):\n                            valid = \'","\'.join(spec[\'options\'])\n                            invalid = \'","\'.join(k for k in param.keys() if \n                                k not in spec[\'options\'])\n                            log.error(f\'Parameter "{path}" expected to only \'\n                                f\'"{valid}" for keys but found "{invalid}".\')\n                            raise ValueError\n                        if \'struct\' in spec:\n                            spec = {k: spec[\'struct\'] for k in param.keys()}\n                            config[attr] = self.verify_config(spec, param, name=path)\n                    else:\n                        log.error(f\'Parameter "{path}" expected to be of type \'\n                            f\'"dict" but found "{type(param).__name__}".\')\n                        raise TypeError\n                elif spec[\'type\'] == \'list\':\n                    if type(param) == list:\n                        if \'min\' in spec and spec[\'min\'] > len(param):\n                            log.error(f\'Parameter "{path}" expected to have at least \'\n                                f\'{spec["min"]} elements but only found {len(param)}.\')\n                            raise ValueError\n                        if \'max\' in spec and spec[\'max\'] < len(param):\n                            log.error(f\'Parameter "{path}" expected to have at most \'\n                                f\'{spec["max"]} elements but found {len(param)}.\')\n                            raise ValueError\n                        if \'struct\' in spec:\n                            spec = {k: spec[\'struct\'] for k in range(len(param))}\n                            config[attr] = self.verify_config(spec,\n                                dict(enumerate(param)), name=path).values()\n                    else:\n                        log.error(f\'Parameter "{path}" expected to be of type \'\n                            f\'"list" but found "{type(param).__name__}".\')\n                        raise TypeError\n                else:\n                    self.verify_param(path, spec, param)\n            else:\n                config[attr] = self.verify_config(spec, param, name=path)\n        \n        return config\n\n    \n    @classmethod\n    def verify_param(self, name, spec, param):\n        \'\'\'validates a single config parameter against a specification\n\n        Parameters\n        ----------\n        name: str\n            Name of the attribute being checked; used in error handling.\n\n        spec: dict\n            A dict containing the attributes of the parameter.\n\n        param: int/float/str/bool\n            The config parameter being validated.\n        \'\'\'\n        types = [self.types[t] for t in spec[\'type\'].split(\',\')]\n\n        if type(param) not in types:\n            types = \'", "\'.join(spec[\'type\'].split(\',\'))\n            log.error(f\'Parameter "{name}" expected to be of type "\'\n                f\'{types}" but found "{type(param).__name__}".\')\n            raise TypeError\n\n        if (\'options\' in spec and len(spec[\'options\']) \n                and param not in spec[\'options\']):\n            options = \', \'.join([f\'"{str(opt)}"\' for opt in spec[\'options\']])\n            log.error(f\'Parameter "{name}" expected to be {options} \'\n                f\'but found "{param}".\')\n            raise ValueError\n\n        if \'exceptions\' in spec and param in spec[\'exceptions\']:\n            log.error(f\'Parameter "{name}" cannot be "{param}".\')\n            raise ValueError\n\n        if \'min\' in spec and param < spec[\'min\']:\n            log.error(f\'Parameter "{name}" expected to be greater than \'\n                f\'{spec["min"]} but found {name}.\')\n            raise ValueError\n\n        if \'max\' in spec and param > spec[\'max\']:\n            log.error(f\'Parameter "{name}" expected to be less than \'\n                f\'{spec["max"]} but found {param}.\')\n            raise ValueError\n\n        if \'regex\' in spec and not re.search(spec[\'regex\'], param):\n            log.error(f\'Parameter "{name}" expected to match pattern \'\n                f\'{spec["regex"]} but found "{param}".\')\n            raise ValueError\n\n        if \'file\' in spec:\n            if spec[\'file\'] == \'exists\' and not FilesysUtil.file_exists(param):\n                log.error(f\'Parameter "{name}" expected to be an existing file \'\n                    \'but file could not be found.\')\n                raise ValueError\n            elif spec[\'file\'] == \'readable\' and not FilesysUtil.file_readable(param):\n                log.error(f\'Parameter "{name}" expected to be an readable file \'\n                    \'but file could not be read.\')\n                raise ValueError\n            elif spec[\'file\'] == \'writable\' and not FilesysUtil.file_writable(param):\n                log.error(f\'Parameter "{name}" expected to be an writable file \'\n                    \'but file could not be written to.\')\n                raise ValueError\n')
    __stickytape_write_module('icarus/util/filesys.py', "\nimport os\nimport sys\nimport tempfile\nimport subprocess\n\nclass FilesysUtil:\n    @classmethod\n    def file_readable(self, filepath):\n        'check that file can be read'\n        return os.access(filepath, os.R_OK)\n\n\n    @classmethod\n    def file_exists(self, filepath):\n        'check that file exists'\n        return os.path.exists(filepath)\n    \n\n    @classmethod\n    def file_writable(self, filepath):\n        'check that file can be written to'\n        if self.file_exists(filepath):\n            if os.path.isfile(filepath):\n                return os.access(filepath, os.W_OK)\n            else:\n                return False \n        \n        pdir = os.path.dirname(filepath)\n        if not pdir: \n            pdir = '.'\n        return os.access(pdir, os.W_OK)\n\n    \n    @classmethod\n    def delete_file(self, filepath):\n        'delete a file'\n        os.remove(filepath)\n\n\n    @classmethod\n    def create_tempfile(self, suffix=None, delete=True):\n        'create a temporary file'\n        return tempfile.NamedTemporaryFile(suffix=suffix, delete=delete)\n\n\n    @classmethod\n    def format_xml(self, source, target=None):\n        'format an xml file'\n        if target is None:\n            targetfile = self.create_tempfile(suffix='xml', delete=False)\n            target = targetfile.name\n            targetfile.close()\n            subprocess.run(f'xmllint --format {source} > {target}', shell=True)\n            subprocess.run(('mv', target, source), shell=False)\n        else:\n            subprocess.run(f'xmllint --format {source} > {target}', shell=True)\n\n\n    @classmethod\n    def compress_gz(self, source, target=None):\n        'decompress a gz file'\n        if target is None:\n            subprocess.run(('gzip', source), shell=False)\n            return source + '.gz'\n\n    @classmethod\n    def decompress_gz(self, source, target=None):\n        'decompress a gz file'\n        if target is None:\n            targetfile = self.create_tempfile(\n                suffix=source.split('.')[-2], delete=False)\n            target = targetfile.name\n            targetfile.close()\n        subprocess.run(f'gunzip --stdout {source} > {target}', shell=True)\n        return target\n\n    @classmethod\n    def package_resource(self, package, resource):\n        'get filepath of a package file'\n        try:\n            module = os.path.dirname(sys.modules[package].__file__)\n            return os.path.join(module, resource)\n        except:\n            return None")
    __stickytape_write_module('icarus/util/sqlite.py', '\nimport sqlite3\n\n\nclass SqliteUtil:\n    def __init__(self, database):\n        self.name = database\n        self.connection = None\n        self.cursor = None\n        self.open()\n\n\n    def open(self):\n        if self.connection is not None:\n            self.close()\n        self.connection = sqlite3.connect(self.name)\n        self.cursor = self.connection.cursor()\n\n\n    def close(self):\n        self.connection.close()\n        self.connection = None\n        self.cursor = None\n\n\n    def count_rows(self, table):\n        self.cursor.execute(f\'SELECT COUNT(*) from {table};\')\n        return self.cursor.fetchall()[0][0]\n\n    \n    def fetch_tables(self):\n        self.cursor.execute(\'SELECT name FROM sqlite_master WHERE type="table";\')\n        tables = self.cursor.fetchall()\n        return [table[0] for table in tables] \n\n\n    def table_exists(self, *tables):\n        exist = self.fetch_tables()\n        return tuple(set(exist).intersection(tables))\n\n\n    def drop_table(self, *tables):\n        for table in tables:\n            self.cursor.execute(f\'DROP TABLE IF EXISTS {table};\')\n\n    \n    def insert_values(self, table, values, num_cols):\n        self.cursor.executemany(\n            f\'INSERT INTO {table} VALUES({", ".join("?" * num_cols)});\', values)\n')
    
    import os
    import logging as log
    from argparse import ArgumentParser
    
    from icarus.parse.events.events import Events
    from icarus.util.config import ConfigUtil
    from icarus.util.sqlite import SqliteUtil
    
    parser = ArgumentParser()
    parser.add_argument('--folder', type=str, dest='folder', default='.')
    parser.add_argument('--log', type=str, dest='log', default=None)
    parser.add_argument('--level', type=str, dest='level', default='info',
        choices=('notset', 'debug', 'info', 'warning', 'error', 'critical'))
    args = parser.parse_args()
    
    handlers = []
    handlers.append(log.StreamHandler())
    if args.log is not None:
        handlers.append(log.FileHandler(args.log, 'w'))
    log.basicConfig(
        format='%(asctime)s %(levelname)s %(filename)s:%(lineno)s %(message)s',
        level=getattr(log, args.level.upper()),
        handlers=handlers)
    
    path = lambda x: os.path.abspath(os.path.join(args.folder, x))
    home = path('')
    config = ConfigUtil.load_config(path('config.json'))
    
    eventspath = path('output/output_events.xml.gz')
    planspath = path('output/output_plans.xml.gz')
    
    log.info('Running events parsing tool.')
    log.info(f'Loading run data from {home}.')
    
    database = SqliteUtil(path('database.db'))
    events = Events(database)
    
    if not events.ready(eventspath, planspath):
        log.warning('Dependent data not parsed or generated.')
        log.warning('Population generation dependencies include simulation output, '
            'exposure parsing, and network parsing.')
        exit(1)
    elif events.complete():
        log.warning('Events already parsed. Would you like to replace it? [Y/n]')
        if input().lower() not in ('y', 'yes', 'yeet'):
            log.info('User chose to keep existing events; exiting parsing tool.')
            exit()
    
    try:
        log.info('Starting events parsing.')
        events.parse(eventspath, planspath)
    except:
        log.exception('Critical error while parsing events; '
            'terminating process and exiting.')
        exit(1)
    
    
    
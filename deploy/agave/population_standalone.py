#!/usr/bin/env python


import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    open(os.path.join(partial_path, "__init__.py"), "w").write("\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "w") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('icarus/generate/population/population.py', "\nimport logging as log\nfrom typing import Callable\n\nfrom icarus.generate.population.network import Network\nfrom icarus.generate.population.subpopulation import Subpopulation\nfrom icarus.generate.population.trip import Trip\nfrom icarus.generate.population.party import Party\nfrom icarus.generate.population.agent import Agent, Leg\nfrom icarus.generate.population.types import Mode, ActivityType\nfrom icarus.util.sqlite import SqliteUtil\nfrom icarus.util.general import chunk\n\n\nclass Population:\n    def __init__(self, database: SqliteUtil):\n        self.database = database\n\n    \n    def create_tables(self):\n        self.database.drop_table('agents', 'activities', 'legs')\n        self.database.cursor.execute('''\n            CREATE TABLE agents(\n                agent_id MEDIUMINT UNSIGNED,\n                household_id MEDIUMINT UNSIGNED,\n                household_idx SMALLINT UNSIGNED,\n                plan_size TINYINT UNSIGNED,\n                uses_vehicle TINYINT UNSIGNED,\n                uses_walk TINYINT UNSIGNED,\n                uses_bike TINYINT UNSIGNED,\n                uses_transit TINYINT UNSIGNED,\n                uses_party TINYINT UNSIGNED\n            );  ''')\n        self.database.cursor.execute('''\n            CREATE TABLE activities(\n                activity_id INT UNSIGNED,\n                agent_id MEDIUMINT UNSIGNED,\n                agent_idx TINYINT UNSIGNED,\n                type VARCHAR(255),\n                apn VARCHAR(255),\n                `group` MEDIUMINT UNSIGNED,\n                start MEDUMINT UNSIGNED,\n                end MEDIUMINT UNSIGNED,\n                duration MEDIUMINT UNSIGNED\n            );  ''')\n        self.database.cursor.execute('''\n            CREATE TABLE legs(\n                leg_id INT UNSIGNED,\n                agent_id MEDIUMINT UNSIGNED,\n                agent_idx TINYINT UNSIGNED,\n                mode VARCHAR(255),\n                party MEDIUMINT UNSIGNED,\n                start MEDIUMINT UNSIGNED,\n                stop MEDIUMINT UNSIGNED,\n                duration MEDIUMINT UNSIGNED\n            );  ''')\n        self.database.connection.commit()\n\n\n    def fetch_trips(self, min_household, max_household):\n        self.database.cursor.execute(f'''\n            SELECT\n                hhid,\n                pnum,\n                personTripNum,\n                jointTripRole,\n                party,\n                origTaz,\n                origMaz,\n                destTaz,\n                destMaz,\n                origPurp,\n                destPurp,\n                mode,\n                vehId,\n                isamAdjDepMin,\n                isamAdjArrMin,\n                isamAdjDurMin\n            FROM trips\n            WHERE hhid >= {min_household}\n            AND hhid < {max_household}; ''')\n        return self.database.cursor.fetchall()\n\n\n    def create_indexes(self):\n        query = 'CREATE INDEX agents_agent ON agents(agent_id);'\n        self.database.connection.execute(query)\n        query = 'CREATE INDEX agents_household ON agents(household_id, household_idx);'\n        self.database.connection.execute(query)\n        query = 'CREATE INDEX legs_leg ON legs(leg_id);'\n        self.database.connection.execute(query)\n        query = 'CREATE INDEX legs_agent ON legs(agent_id, agent_idx);'\n        self.database.connection.execute(query)\n        query = 'CREATE INDEX activities_activity ON activities(activity_id);'\n        self.database.connection.execute(query)\n        query = 'CREATE INDEX activities_agent ON activities(agent_id, agent_idx);'\n        self.database.connection.execute(query)\n        query = 'CREATE INDEX activities_parcel ON activities(apn);'\n        self.database.connection.execute(query)\n\n\n    def fetch_count(self, table):\n        self.database.cursor.execute(f'SELECT COUNT(*) FROM {table};')\n        return self.database.cursor.fetchall()[0][0]\n\n    \n    def ready(self):\n        tables = ('trips', 'regions', 'parcels')\n        exists = self.database.table_exists(*tables)\n        if len(exists) < len(tables):\n            missing = ', '.join(set(tables) - set(exists))\n            log.info(f'Could not find tables {missing} in database.')\n        return len(exists) == len(tables)\n\n\n    def complete(self):\n        tables = ('agents', 'activities', 'legs')\n        exists = self.database.table_exists(*tables)\n        if len(exists):\n            present = ', '.join(exists)\n            log.info(f'Found tables {present} already in database.')\n        return len(exists) > 0\n    \n\n    def generate(self, modes=None, activity_types=None, seed=None):\n        log.info('Loading process metadata.')\n        size = self.fetch_count('households')\n\n        if modes is None:\n            modes = set(Mode)\n        else:\n            modes = set((Mode(mode) for mode in modes))\n        if activity_types is None:\n            activity_types = set(ActivityType)\n        else:\n            activity_types = set((ActivityType(act) for act in activity_types))\n\n        log.info('Preparing tables for population.')\n        self.create_tables()\n        \n        log.info('Loading network data.')\n        network = Network(self.database)\n        network.load_network()\n\n        log.info('Iterating over trips for each household.')\n\n        def valid_party(party: Party) -> bool:\n            return party.driver is not None\n\n        def valid_leg(leg: Leg) -> bool:\n            distance = network.minimum_distance(leg.party.origin_group.maz, \n                leg.party.dest_group.maz)\n            duration  = leg.end - leg.start\n            valid = False\n            if duration > 0:\n                valid = distance / duration < leg.mode.route_mode().max_speed()\n            elif distance == 0:\n                valid = True\n            return valid\n\n        def valid_agent(agent: Agent) -> bool:\n            return (agent.modes.issubset(modes)\n                and agent.activity_types.issubset(activity_types)\n                and agent.mazs.issubset(network.mazs)\n                and all(valid_party(party) for party in agent.parties)\n                and all(valid_leg(leg) for leg in agent.legs))\n\n        for min_household, max_household in chunk(0, size, 100000):\n            log.info(f'Fetching trips from household {min_household}'\n                f' to {max_household}.')\n            subpopulation = Subpopulation()\n            trips = self.fetch_trips(min_household, max_household)\n\n            log.info('Parsing fetched trips.')\n            for trip_data in trips:\n                trip = Trip(trip_data)\n                subpopulation.parse_trip(trip)\n\n            log.info('Filtering agents.')\n            subpopulation.filter(valid_agent)\n            log.info('Cleaning up population.')\n            subpopulation.clean()\n            log.info('Assigning parcels to activities.')\n            subpopulation.assign_parcels(network)\n            log.info('Identifying activity, leg and agent ids.')\n            subpopulation.identify()\n\n            log.info('Writing generated population to database.')\n            agents = subpopulation.export_agents()\n            self.database.insert_values('agents', agents, 9)\n            activities = subpopulation.export_activities()\n            self.database.insert_values('activities', activities, 9)\n            legs = subpopulation.export_legs()\n            self.database.insert_values('legs', legs, 8)\n            self.database.connection.commit()\n\n        self.create_indexes()\n        self.database.connection.commit()\n        \n")
    __stickytape_write_module('icarus/generate/population/network.py', "\nimport logging as log\n\nfrom shapely.geometry import Polygon\nfrom random import randint\nfrom icarus.util.sqlite import SqliteUtil\nfrom icarus.util.general import defaultdict, counter\n\n\nclass Parcel:\n    __slots__ = ('apn',)\n\n    def __init__(self, apn: str):\n        self.apn = apn\n\n\nclass Region:\n    __slots__ = ('polygon',)\n\n    @staticmethod\n    def region_coords(region: str):\n        coords = []\n        points = region[10:-2].split(', ')\n        for point in points:\n            x, y = point.split(' ')\n            coords.append((float(x) * 0.3048, float(y) * 0.3048))\n        return coords\n    \n    def __init__(self, polygon: str):\n        self.polygon = Polygon(self.region_coords(polygon))\n\n\nclass Network:\n    def __init__(self, database: SqliteUtil):\n        self.database = database\n        self.loaded = False\n\n    \n    def fetch_parcels(self):\n        self.database.cursor.execute(f'''\n            SELECT\n                apn,\n                maz,\n                type\n            FROM parcels\n            ORDER BY \n                RANDOM(); ''')\n\n        return self.database.cursor.fetchall()\n\n    \n    def fetch_regions(self):\n        query = '''\n            SELECT\n                maz,\n                region\n            FROM regions;   '''\n        self.database.cursor.execute(query)\n        return self.database.cursor.fetchall()\n\n\n    def load_parcels(self):\n        parcels = self.fetch_parcels()\n        self.residential_parcels = defaultdict(lambda x: [])\n        self.commercial_parcels = defaultdict(lambda x: [])\n        self.default_parcels = {}\n        self.other_parcels = defaultdict(lambda x: [])\n\n        for apn, maz, kind in counter(parcels, 'Loading parcel %s.'):\n            if kind == 'residential':\n                self.residential_parcels[maz].append(Parcel(apn))\n            elif kind == 'commercial':\n                self.commercial_parcels[maz].append(Parcel(apn))\n            elif kind == 'default':\n                self.default_parcels[maz] = Parcel(apn)\n            elif kind == 'other':\n                self.other_parcels[maz].append(Parcel(apn))\n\n        self.residential_parcels.lock()\n        self.commercial_parcels.lock()\n        self.other_parcels.lock()\n\n        self.mazs = set(self.default_parcels.keys())\n        self.offset = defaultdict(lambda x: 0)\n\n\n    def load_regions(self):\n        regions = self.fetch_regions()\n        self.regions = {}\n        for maz, polygon in counter(regions, 'Loading region %s.'):\n            self.regions[maz] = Region(polygon)\n        return regions\n\n\n    def load_network(self):\n        log.info('Loading parcel data.')\n        self.load_parcels()\n        log.info('Loading region data.')\n        self.load_regions()\n        self.loaded = True\n\n\n    def minimum_distance(self, maz1: str, maz2: str) -> float:\n        return self.regions[maz1].polygon.distance(self.regions[maz2].polygon)\n\n\n    def random_household_parcel(self, maz:str) -> Parcel:\n        parcel = None\n        if maz in self.mazs:\n            if maz in self.residential_parcels:\n                idx = self.offset[maz]\n                parcel  = self.residential_parcels[maz][idx]\n                self.offset[maz] = (idx + 1) % len(self.residential_parcels[maz])\n            elif maz in self.commercial_parcels:\n                idx = randint(0, len(self.commercial_parcels[maz]) - 1)\n                parcel = self.commercial_parcels[maz][idx]\n            elif maz in self.other_parcels:\n                idx = randint(0, len(self.other_parcels[maz]) - 1)\n                parcel = self.other_parcels[maz][idx]\n            elif maz in self.default_parcels:\n                parcel = self.default_parcels[maz]\n        return parcel\n\n\n    def random_activity_parcel(self, maz: str) -> Parcel:\n        parcel = None\n        if maz in self.mazs:\n            if maz in self.commercial_parcels:\n                idx = randint(0, len(self.commercial_parcels[maz]) - 1)\n                parcel = self.commercial_parcels[maz][idx]\n            elif maz in self.other_parcels:\n                idx = randint(0, len(self.other_parcels[maz]) - 1)\n                parcel = self.other_parcels[maz][idx]\n            elif maz in self.residential_parcels:\n                idx = randint(0, len(self.residential_parcels[maz]) - 1)\n                parcel = self.residential_parcels[maz][idx]\n            elif maz in self.default_parcels:\n                parcel = self.default_parcels[maz]\n        return parcel")
    __stickytape_write_module('icarus/util/sqlite.py', '\nimport sqlite3\n\n\nclass SqliteUtil:\n    def __init__(self, database):\n        self.name = database\n        self.connection = None\n        self.cursor = None\n        self.open()\n\n\n    def open(self):\n        if self.connection is not None:\n            self.close()\n        self.connection = sqlite3.connect(self.name)\n        self.cursor = self.connection.cursor()\n\n\n    def close(self):\n        self.connection.close()\n        self.connection = None\n        self.cursor = None\n\n\n    def count_rows(self, table):\n        self.cursor.execute(f\'SELECT COUNT(*) from {table};\')\n        return self.cursor.fetchall()[0][0]\n\n    \n    def fetch_tables(self):\n        self.cursor.execute(\'SELECT name FROM sqlite_master WHERE type="table";\')\n        tables = self.cursor.fetchall()\n        return [table[0] for table in tables] \n\n\n    def table_exists(self, *tables):\n        exist = self.fetch_tables()\n        return tuple(set(exist).intersection(tables))\n\n\n    def drop_table(self, *tables):\n        for table in tables:\n            self.cursor.execute(f\'DROP TABLE IF EXISTS {table};\')\n\n    \n    def insert_values(self, table, values, num_cols):\n        self.cursor.executemany(\n            f\'INSERT INTO {table} VALUES({", ".join("?" * num_cols)});\', values)\n')
    __stickytape_write_module('icarus/__init__.py', '')
    __stickytape_write_module('icarus/util/__init__.py', '')
    __stickytape_write_module('icarus/util/general.py', '\nimport logging as log\n\n\ndef chunk(start, stop, chunk):\n    bins = zip(range(start, stop, chunk), \n        range(start+chunk, stop+chunk, chunk))\n    for low, high in bins:\n        yield low, high\n\n\ndef bins(iterable, binsize):\n    for idx in range(0, len(iterable), binsize):\n        yield iterable[idx : idx + binsize]\n\n\ndef counter(iterable, message, start=1, end=True):\n    n = 1\n    count = 0\n    for count, item in enumerate(iterable, start):\n        if count == n:\n            log.info(message % count)\n            n <<= 1\n        yield item\n    if count != n >> 1 and end:\n        log.info(message % count)\n\n\nclass defaultdict(dict):\n    def __init__(self, function):\n        self.function = function\n        self.locked = False\n\n    def __getitem__(self, item):\n        if item in self:\n            return super().__getitem__(item)\n        elif not self.locked:\n            value = self.function(item)\n            self[item] = value\n            return value\n        else:\n            raise KeyError\n    \n    def lock(self):\n        self.locked = True\n\n    def unlock(self):\n        self.locked = False\n\n')
    __stickytape_write_module('icarus/generate/__init__.py', '')
    __stickytape_write_module('icarus/generate/population/__init__.py', '')
    __stickytape_write_module('icarus/generate/population/subpopulation.py', '\nfrom typing import Dict, Callable, Iterator\nfrom icarus.generate.population.network import Network\nfrom icarus.generate.population.household import Household\nfrom icarus.generate.population.trip import Trip\nfrom icarus.generate.population.agent import Agent, Activity, Leg\nfrom icarus.util.general import defaultdict\n\nclass Subpopulation:\n    def __init__(self):\n        self.households: Dict[int, Household] = defaultdict(lambda x: Household(x))\n        self.last_trip: Trip = None\n\n\n    def total_agents(self) -> int:\n        return sum(len(hh.agents) for hh in self.households.values())\n\n\n    def get_agent(self, trip: Trip) -> Agent:\n        return self.households[trip.household_id].agents[trip.agent_id]\n\n    \n    def parse_trip(self, trip: Trip):\n        if self.last_trip is not None:\n            if self.last_trip.household_id == trip.household_id:\n                self.households[self.last_trip.household_id].parse_trip(\n                    self.last_trip, trip)\n            else:\n                self.households[self.last_trip.household_id].parse_trip(\n                    self.last_trip, None)\n        self.last_trip = trip\n    \n    \n    def filter(self, valid: Callable[[Agent], bool]) -> int:\n        removed = 0\n        for household in self.households.values():\n            removed += household.filter(valid)\n        return removed\n\n    def clean(self):\n        for household in self.households.values():\n            household.clean()\n\n    def identify(self):\n        for household in self.households.values():\n            household.identify()\n\n    def export_agents(self) -> Iterator[Agent]:\n        for household in self.households.values():\n            agents = household.export_agents()\n            for agent in agents:\n                yield agent\n\n    def export_activities(self) -> Iterator[Activity]:\n        for household in self.households.values():\n            activities = household.export_activities()\n            for activity in activities:\n                yield activity\n\n    def export_legs(self) -> Iterator[Leg]:\n        for household in self.households.values():\n            legs = household.export_legs()\n            for leg in legs:\n                yield leg\n\n    def assign_parcels(self, network: Network):\n        for household in self.households.values():\n            household.assign_parcels(network)')
    __stickytape_write_module('icarus/generate/population/household.py', "\nfrom typing import Dict\nfrom icarus.generate.population.agent import Agent\nfrom icarus.generate.population.party import Party\nfrom icarus.generate.population.vehicle import Vehicle\nfrom icarus.generate.population.group import Group\nfrom icarus.generate.population.types import Mode\n\n\nclass Household:\n    __slots__ = ('id', 'parties', 'agents', 'vehicles', 'groups', 'parcel', 'maz')\n    \n    def __init__(self, household):\n        self.id = household\n        self.parties = {}\n        self.agents = {}\n        self.vehicles = {}\n        self.groups = set()\n        self.parcel = None\n        self.maz = None\n\n    \n    def get_party(self, depart_time, arrive_time, members):\n        party_hash = Party.party_hash(depart_time, arrive_time, members)\n        party = None\n        if party_hash in self.parties:\n            party = self.parties[party_hash]\n        else:\n            party = Party()\n            self.parties[party_hash] = party\n        return party\n\n\n    def get_agent(self, agent_id):\n        agent = None\n        if agent_id in self.agents:\n            agent = self.agents[agent_id]\n        else:\n            agent = Agent(agent_id)\n            self.agents[agent_id] = agent\n        return agent\n\n\n    def get_vehicle(self, mode, household_id, agent_id, vehicle_id):\n        vehicle_hash = Vehicle.vehicle_hash(mode, household_id, agent_id, vehicle_id)\n        vehicle = None\n        if vehicle_hash in self.vehicles:\n            vehicle = self.vehicles[vehicle_hash]\n        else:\n            vehicle = Vehicle(vehicle_hash)\n            self.vehicles[vehicle_hash] = vehicle\n        return vehicle\n\n\n    def filter(self, valid):\n        remove = set()\n        for agent in self.agents.values():\n            if agent not in remove:\n                if not valid(agent):\n                    remove = remove.union(agent.dependents())\n        for agent in remove:\n            agent.safe_delete()\n            del self.agents[agent.agent_id]\n        return len(remove)\n\n\n    def clean(self):\n        remove = set()\n        for key, party in self.parties.items():\n            if len(party.agents) == 0:\n                remove.add(key)\n        for key in remove:\n            del self.parties[key]\n        self.groups = filter(lambda group: len(group.agents) > 0, self.groups)\n\n    \n    def identify(self):\n        for party in self.parties.values():\n            party.request_id()\n        for agent in self.agents.values():\n            agent.request_id()\n            for activity in agent.activities:\n                activity.request_id()\n            for leg in agent.legs:\n                leg.request_id()\n        for group in self.groups:\n            group.request_id()\n\n\n    def export_agents(self):\n        for agent_id, agent in self.agents.items():\n            yield (\n                agent.id,\n                self.id,\n                agent_id,\n                agent.size(),\n                agent.uses_vehicle(),\n                agent.uses_walk(),\n                agent.uses_bike(),\n                agent.uses_transit(),\n                agent.uses_party())\n\n    \n    def export_activities(self):\n        for agent in self.agents.values():\n            for activity in agent.export_activities():\n                yield activity\n    \n    \n    def export_legs(self):\n        for agent in self.agents.values():\n            for leg in agent.export_legs():\n                yield leg\n        \n\n    def parse_trip(self, trip, next_trip=None):\n        agent = self.get_agent(trip.agent_id)\n\n        mode = Mode(trip.mode)\n        vehicle = self.get_vehicle(mode, trip.household_id, \n            trip.agent_id, trip.vehicle_id)\n        \n        party = self.get_party(trip.depart_time, trip.arrive_time, trip.party)\n        if next_trip is None:\n            next_party = Party()\n        else:\n            next_party = self.get_party(next_trip.depart_time, \n                next_trip.arrive_time, next_trip.party)\n\n        if party.origin_group is None:\n            party.set_origin_group(Group(trip.origin_maz))\n            self.groups.add(party.origin_group)\n        if party.dest_group is None:\n            if next_party.origin_group is None:\n                party.set_dest_group(Group(trip.dest_maz))\n                next_party.set_origin_group(party.dest_group)\n                self.groups.add(party.dest_group)\n            else:\n                party.set_dest_group(next_party.origin_group)\n        else:\n            if next_party.origin_group is None:\n                next_party.set_origin_group(party.dest_group)\n            elif party.dest_group != next_party.origin_group:\n                party.dest_group.merge_group(next_party.origin_group)\n                next_party.origin_group = party.dest_group\n\n        if self.maz is None:\n            self.maz = trip.origin_maz\n\n        try:\n            agent.parse_trip(trip, vehicle, party)\n        except Exception:\n            breakpoint()\n\n    \n    def assign_parcels(self, network):\n        self.parcel = network.random_household_parcel(self.maz)\n        for group in self.groups:\n            parcel = None\n            if group.home:\n                parcel = self.parcel\n            else:\n                parcel = network.random_activity_parcel(group.maz)\n\n            group.assign_parcel(parcel)\n")
    __stickytape_write_module('icarus/generate/population/agent.py', "\nfrom __future__ import annotations\nfrom typing import Set, List, Iterator, Tuple\n\nfrom icarus.generate.population.party import Party\nfrom icarus.generate.population.trip import Trip\nfrom icarus.generate.population.group import Group\nfrom icarus.generate.population.vehicle import Vehicle\nfrom icarus.generate.population.network import Parcel\nfrom icarus.generate.population.types import ActivityType, Mode\n\n\nclass Leg:\n    uuid = 0\n    __slots__ = ('id', 'mode', 'start', 'end', 'party', 'vehicle')\n\n    def __init__(self, mode: Mode, start: int, end: int, party: Party):\n        self.mode = mode\n        self.start = start\n        self.end = end\n        self.party = party\n        self.vehicle = None\n        self.id = None\n\n\n    def request_id(self):\n        if self.id is None:\n            Leg.uuid += 1\n            self.id = Leg.uuid\n\n\n    def assign_vehicle(self, vehicle: Vehicle):\n        self.vehicle = vehicle\n\n\n\nclass Activity:\n    uuid = 0\n    __slots__ = ('activity_type', 'start', 'end', 'maz', 'group', 'parcel', 'id')\n\n    def __init__(self, activity_type: ActivityType, start: int, end:int,\n            maz: int, group: Group):\n        self.activity_type = activity_type\n        self.start = start\n        self.end = end\n        self.maz = maz\n        self.group = group\n        self.parcel = None\n        self.id = None\n\n\n    def request_id(self):\n        if self.id is None:\n            Activity.uuid += 1\n            self.id = Activity.uuid\n\n    \n    def assign_parcel(self, parcel: Parcel):\n        self.parcel = parcel\n\n\n\nclass Agent:\n    uuid = 0\n    __slots__ = ('agent_id', 'activities', 'legs', 'modes', 'activity_types',\n            'mazs', 'parties', 'groups', 'id')\n\n    def __init__(self, agent_id: str):\n        self.agent_id: str = agent_id\n        self.activities: List[Activity] = []\n        self.legs: List[Leg] = []\n        self.modes: Set[Mode] = set()\n        self.activity_types: Set[ActivityType] = set()\n        self.mazs: Set[int] = set()\n        self.parties: Set[Party] = set()\n        self.groups: Set[Group] = set()\n        self.id: int = None\n\n    def request_id(self):\n        if self.id is None:\n            Agent.uuid += 1\n            self.id = Agent.uuid\n\n    def uses_walk(self) -> bool:\n        return Mode.WALK in self.modes\n\n    def uses_vehicle(self) -> bool:\n        return any((mode.vehicle() for mode in self.modes))\n\n    def uses_bike(self) -> bool:\n        return Mode.BIKE in self.modes\n\n    def uses_transit(self) -> bool:\n        return any((mode.transit() for mode in self.modes))\n\n    def uses_party(self) -> bool:\n        return any((len(party.agents) > 1 for party in self.parties))\n\n    def size(self) -> int:\n        return len(self.activities) + len(self.legs)\n    \n\n    def dependents(self, agents: Set[Agent] = None) -> Set[Agent]:\n        if agents is None:\n            agents = set()\n        agents.add(self)\n        for party in self.parties:\n            if party.driver == self:\n                for agent in party.agents:\n                    if agent not in agents:\n                        agents = agent.dependents(agents)\n        return agents\n\n\n    def safe_delete(self):\n        for party in self.parties:\n            party.remove_agent(self)\n            if party.driver == self:\n                party.set_driver(None, None)\n        for group in self.groups:\n            group.remove_agent(self)\n        for leg in self.legs:\n            leg.party.remove_leg(leg)\n        for activity in self.activities:\n            activity.group.remove_activity(activity)\n        self.parties = set()\n        self.groups = set()\n        self.legs = []\n        self.activities = []\n\n\n    def export_activities(self) -> Iterator[Tuple]:\n        activities = ((\n            act.id,\n            self.id,\n            idx,\n            act.activity_type.name.lower(),\n            act.parcel.apn,\n            act.group.id or 0,\n            act.start,\n            act.end,\n            act.end - act.start\n        ) for idx, act in enumerate(self.activities))\n        return activities\n\n\n    def export_legs(self) -> Iterator[Tuple]:\n        legs = ((\n            leg.id,\n            self.id,\n            idx,\n            leg.mode.route_mode().value,\n            leg.party.id or 0,\n            leg.start,\n            leg.end,\n            leg.end - leg.start\n        ) for idx, leg in enumerate(self.legs))\n        return legs\n\n\n    def last_group(self) -> Group:\n        group = None\n        if len(self.activities):\n            group = self.activities[-1].group\n        return group\n\n\n    def last_party(self) -> Party:\n        leg = None\n        if len(self.legs):\n            leg = self.legs[-1].leg\n        return leg\n\n\n    def parse_trip(self, trip: Trip, vehicle: Vehicle, party: Party):\n        if vehicle is not None:\n            party.set_driver(self, vehicle)\n                \n        if trip.agent_idx == 1:\n            activity_type = ActivityType(trip.origin_act)\n            start = 14400\n            end = int(trip.depart_time * 60) + 14400\n            activity = Activity(activity_type, start, end, \n                trip.origin_maz, party.origin_group)\n            self.activity_types.add(activity_type)\n            self.mazs.add(trip.origin_maz)\n            self.activities.append(activity)\n            party.origin_group.add_activity(activity, self)\n            self.groups.add(party.origin_group)\n\n        mode = Mode(trip.mode)\n        start = int(trip.depart_time * 60) + 14400\n        end = int(trip.arrive_time * 60) + 14400\n        leg = Leg(mode, start, end, party)\n        self.modes.add(mode)\n        self.legs.append(leg)\n        party.add_leg(leg, self)\n        self.parties.add(party)\n\n        activity_type = ActivityType(trip.dest_act)\n        start = end\n        end += int(trip.act_duration * 60)\n        activity = Activity(activity_type, start, end, \n            trip.dest_maz, party.dest_group)\n        self.activity_types.add(activity_type)\n        self.mazs.add(trip.dest_maz)\n        self.activities.append(activity)\n        party.dest_group.add_activity(activity, self)\n        self.groups.add(party.dest_group)\n")
    __stickytape_write_module('icarus/generate/population/party.py', "\nfrom typing import Set\n\nfrom icarus.generate.population.types import RouteMode\n\n\nclass Party:\n    uuid = 0\n    __slots__ = ('origin_group', 'dest_group', 'legs', 'agents', 'driver',\n        'vehicle', 'mode', 'id')\n\n    @staticmethod\n    def party_hash(depart_time, arrive_time, members):\n        agent_ids = members[2:-2].split(',')\n        return (depart_time, arrive_time, frozenset(agent_ids))\n\n    \n    def __init__(self):\n        self.origin_group = None\n        self.dest_group = None\n        self.legs = set()\n        self.agents = set()\n        self.driver = None\n        self.vehicle = None\n        self.mode = None\n        self.id = None\n\n\n    def request_id(self):\n        if self.id is None and len(self.agents) > 1:\n            Party.uuid += 1\n            self.id = Party.uuid\n\n    \n    def add_leg(self, leg, agent):\n        if len(self.legs) < 1:\n            self.mode = leg.mode.route_mode()\n        self.agents.add(agent)\n        self.legs.add(leg)\n\n\n    def assign_vehicles(self):\n        for leg in self.legs:\n            leg.assign_vehicle(self.vehicle)\n\n    \n    def set_driver(self, driver, vehicle):\n        self.driver = driver\n        self.vehicle = vehicle\n\n\n    def set_origin_group(self, group):\n        if self.origin_group is None:\n            self.origin_group = group\n            group.add_party(self)\n\n\n    def set_dest_group(self, group):\n        if self.dest_group is None:\n            self.dest_group = group\n            group.add_party(self)\n\n\n    def remove_agent(self, agent):\n        self.agents.remove(agent)\n\n    \n    def remove_leg(self, leg):\n        self.legs.remove(leg)\n\n\n    def replace_group(self, old_group, new_group):\n        if self.dest_group == old_group:\n            self.dest_group = new_group\n        elif self.origin_group == old_group:\n            self.origin_group = new_group\n        else:\n            raise ValueError")
    __stickytape_write_module('icarus/generate/population/types.py', "\nfrom enum import IntEnum, Enum\n\n\nclass RouteMode(Enum):\n    WALK = 'walk'\n    BIKE = 'bike'\n    CAR = 'car'\n    PT = 'pt'\n\n    def max_speed(self) -> float:\n        speed = None\n        if self == self.WALK:\n            speed = 3.0\n        elif self == self.BIKE:\n            speed = 10.0\n        elif self == self.CAR:\n            speed = 35\n        elif self == self.PT:\n            speed = 30\n        return speed\n\n\nclass ActivityType(IntEnum):\n    HOME = 0\n    WORKPLACE = 1\n    UNIVERSITY = 2\n    SCHOOL = 3\n    ESCORT = 4\n    SCHOOL_ESCORT = 41\n    PURE_ESCORT = 411\n    RIDESHARE_ESCORT = 412\n    OTHER_ESCORT = 42\n    SHOPPING = 5\n    OTHER_MAINTENANCE = 6\n    EATING_OUT = 7\n    BREAKFAST = 71\n    LUNCH = 72\n    DINNER = 73\n    VISITING = 8\n    OTHER_DISCRETIONARY = 9\n    SPECIAL_EVENT = 10\n    WORK = 11\n    WORK_BUSINESS = 12\n    WORK_LUNCH = 13\n    WORK_OTHER = 14\n    WORK_RELATED = 15\n    ASU = 16\n\n    def escort(self) -> bool:\n        return self in (\n            self.ESCORT,\n            self.SCHOOL_ESCORT,\n            self.PURE_ESCORT,\n            self.RIDESHARE_ESCORT,\n            self.OTHER_ESCORT   )\n\n\nclass Mode(IntEnum):\n    SOV = 1\n    HOV2 = 2\n    HOV3 = 3\n    PASSENGER = 4\n    CONV_TRANS_WALK = 5\n    CONV_TRANS_KNR = 6\n    CONV_TRANS_PNR = 7\n    PREM_TRANS_WALK = 8\n    PREM_TRANS_KNR = 9\n    PREM_TRANS_PNR = 10\n    WALK = 11\n    BIKE = 12\n    TAXI = 13\n    SCHOOL_BUS = 14\n\n    def transit(self) -> bool:\n        return self in (\n            self.CONV_TRANS_WALK,\n            self.CONV_TRANS_KNR,\n            self.CONV_TRANS_PNR,\n            self.PREM_TRANS_WALK,\n            self.PREM_TRANS_KNR,\n            self.PREM_TRANS_PNR )\n\n    def vehicle(self) -> bool:\n        return self in (\n            self.SOV,\n            self.HOV2,\n            self.HOV3,\n            self.PASSENGER,\n            self.TAXI,\n            self.SCHOOL_BUS )\n\n    def route_mode(self) -> RouteMode:\n        route_mode = None\n        if self.transit():\n            route_mode = RouteMode.PT\n        elif self.vehicle():\n            route_mode = RouteMode.CAR\n        elif self == self.WALK:\n            route_mode = RouteMode.WALK\n        elif self == self.BIKE:\n            route_mode = RouteMode.BIKE\n        return route_mode")
    __stickytape_write_module('icarus/generate/population/trip.py', "\n\nclass Trip:\n    uuid = 0\n    __slots__ = ('household_id', 'agent_id', 'agent_idx', 'party_role', 'party', \n        'origin_taz', 'origin_maz', 'dest_taz',  'dest_maz', 'origin_act', \n        'dest_act', 'mode', 'vehicle_id', 'depart_time', \n        'arrive_time', 'act_duration')    \n    \n\n    def __init__(self, trip):\n        self.household_id, self.agent_id, self.agent_idx, self.party_role, \\\n            self.party, self.origin_taz, self.origin_maz, self.dest_taz, \\\n            self.dest_maz, self.origin_act, self.dest_act, self.mode, \\\n            self.vehicle_id, self.depart_time, self.arrive_time, \\\n            self.act_duration = trip")
    __stickytape_write_module('icarus/generate/population/group.py', "\nfrom icarus.generate.population.types import ActivityType\n\nclass Group:\n    uuid = 0\n    __slots__ = ('maz', 'activities', 'agents', 'parties', 'home', 'id')\n\n    @staticmethod\n    def group_hash(time, members):\n        agent_ids = members[2:-2].split(',')\n        party_hash = None\n        if len(agent_ids) > 1:\n            party_hash = (time, frozenset(agent_ids))\n        return party_hash\n\n    \n    def __init__(self, maz):\n        self.maz = maz\n        self.activities = set()\n        self.agents = set()\n        self.parties = set()\n        self.home = False\n        self.id = None\n\n    \n    def request_id(self):\n        if self.id is None and len(self.agents) > 1:\n            Group.uuid += 1\n            self.id = Group.uuid\n\n\n    def add_party(self, party):\n        self.parties.add(party)\n\n\n    def remove_party(self, party):\n        self.parties.remove(party)\n\n\n    def merge_group(self, group):\n        self.agents = self.agents.union(group.agents)\n        self.activities = self.activities.union(group.activities)\n        self.parties = self.parties.union(group.parties)\n        self.home |= group.home\n        for agent in group.agents:\n            agent.groups.remove(group)\n            agent.groups.add(self)\n        for activity in group.activities:\n            activity.group = self\n        for party in group.parties:\n            party.replace_group(group, self)\n        group.agents = set()\n        group.activities = set()\n        group.parties = set()\n\n\n    def assign_parcel(self, parcel):\n        for activity in self.activities:\n            activity.assign_parcel(parcel)\n\n    \n    def add_activity(self, activity, agent):\n        self.agents.add(agent)\n        self.activities.add(activity)\n        if activity.activity_type == ActivityType.HOME:\n            self.home = True\n\n\n    def remove_agent(self, agent):\n        self.agents.remove(agent)\n\n\n    def remove_activity(self, activity):\n        self.activities.remove(activity)")
    __stickytape_write_module('icarus/generate/population/vehicle.py', "\nfrom icarus.generate.population.types import Mode\n\nclass Vehicle:\n    @staticmethod\n    def vehicle_hash(mode, household_id=None, agent_id=None, vehicle_id=None):\n        vehicle_hash = None\n        if mode == Mode.WALK:\n            vehicle_hash = f'{household_id}-{agent_id}-walk'\n        elif mode == Mode.BIKE:\n            vehicle_hash = f'{household_id}-{agent_id}-bike'\n        elif mode.transit():\n            vehicle_hash = f'{household_id}-{agent_id}-pt'\n        elif mode.vehicle() and vehicle_id > 0:\n            vehicle_hash = f'{household_id}-{vehicle_id}-car'\n                \n        return vehicle_hash\n\n\n    def __init__(self, uuid):\n        self.id = uuid")
    __stickytape_write_module('icarus/util/config.py', '\nimport json\nimport re\nimport os\n\nimport logging as log\n\nfrom icarus.util.filesys import FilesysUtil\n\n\nclass ConfigUtil:\n    \'\'\'static class used to verify config to specs for runner\n\n    also includes some useful tools for handling config parameters\n    \'\'\'\n    types = {\'str\': str, \'int\': int, \'bool\': bool, \'dict\': dict,\n        \'list\': list, \'float\': float, \'null\': None}\n\n\n    @classmethod\n    def load_config(self, filepath):\n        \'load a config file; catches file and JSON errors\'\n\n        config = None\n        try:\n            with open(filepath) as handle:\n                config =  json.load(handle)\n        except FileNotFoundError as err:\n            log.exception(f\'Config file "{filepath}" does not exist; \'\n                \'terminating model run.\')\n            raise err\n        except json.JSONDecodeError as err:\n            log.exception(f\'Config file "{filepath}" is not valid json; \'\n                \'terminating model run.\')\n            raise err\n        return config\n        \n\n    @classmethod\n    def load_specs(self, filepath):\n        \'load a config file; catches file and JSON errors\'\n\n        specs = None\n        try:\n            with open(filepath) as handle:\n                specs = json.load(handle)\n        except FileNotFoundError as err:\n            log.exception(f\'Specs file "{filepath}" does not exist; \'\n                \'terminating model run.\')\n            raise err\n        except json.JSONDecodeError as err:\n            log.exception(f\'Specs file "{filepath}" is not valid json; \'\n                \'terminating model run.\')\n            raise err\n        return specs\n\n\n    @classmethod\n    def verify_config(self, specs, config, name=\'\'):\n        \'\'\'recursively validates a a configuration dict againast a \n        specifications dict\n\n        Parameters\n        ----------\n        specs: dict\n            The dict representing a JSON specifications file.\n\n        config: dict\n            The dict representing a JSON configurations file; will be checked\n            against the specifications file.\n\n        name: str\n            The name of the specification property; used in error handling. This\n            is set recursively; the intial name is an empty string.\n\n        Returns\n        -------\n        config: dict\n            A new dict representing the JSON configuration file with any missing\n            default values added onto it.\n        \'\'\'\n\n        for attr in config.keys():\n            if attr not in specs.keys():\n                if type(attr) is int:\n                    path = f\'{name}[{attr}]\' if name != \'\' else attr\n                else:\n                    path = f\'{name}.{attr}\' if name != \'\' else attr\n                log.warning(f\'Config parameter "{path}" is not in model \'\n                    \'specifications; it will not impact model run.\')\n\n        for attr, spec in specs.items():\n            param = config[attr] if attr in config else None\n            if type(attr) is int:\n                path = f\'{name}[{attr}]\' if name != \'\' else attr\n            else:\n                path = f\'{name}.{attr}\' if name != \'\' else attr\n\n            if type(spec) is not dict:\n                config[attr] = spec\n            elif \'type\' in spec:\n                if param is None:\n                    if \'required\' not in spec or not spec[\'required\']:\n                        config[attr] = spec[\'default\'] if \'default\' in spec else None\n                    else:\n                        log.error(f\'Parameter "{attr}" is required.\')\n                        raise ValueError\n                elif spec[\'type\'] == \'dict\':\n                    if type(param) == dict:\n                        if \'min\' in spec and spec[\'min\'] > len(param):\n                            log.error(f\'Parameter "{path}" expected to have at least \'\n                                f\'{spec["min"]} elements but only found {len(param)}.\')\n                            raise ValueError\n                        if \'max\' in spec and spec[\'max\'] < len(param):\n                            log.error(f\'Parameter "{path}" expected to have at most \'\n                                f\'{spec["max"]} elements but found {len(param)}.\')\n                            raise ValueError\n                        if \'options\' in spec and not all(k in spec[\'options\'] \n                                for k in param.keys()):\n                            valid = \'","\'.join(spec[\'options\'])\n                            invalid = \'","\'.join(k for k in param.keys() if \n                                k not in spec[\'options\'])\n                            log.error(f\'Parameter "{path}" expected to only \'\n                                f\'"{valid}" for keys but found "{invalid}".\')\n                            raise ValueError\n                        if \'struct\' in spec:\n                            spec = {k: spec[\'struct\'] for k in param.keys()}\n                            config[attr] = self.verify_config(spec, param, name=path)\n                    else:\n                        log.error(f\'Parameter "{path}" expected to be of type \'\n                            f\'"dict" but found "{type(param).__name__}".\')\n                        raise TypeError\n                elif spec[\'type\'] == \'list\':\n                    if type(param) == list:\n                        if \'min\' in spec and spec[\'min\'] > len(param):\n                            log.error(f\'Parameter "{path}" expected to have at least \'\n                                f\'{spec["min"]} elements but only found {len(param)}.\')\n                            raise ValueError\n                        if \'max\' in spec and spec[\'max\'] < len(param):\n                            log.error(f\'Parameter "{path}" expected to have at most \'\n                                f\'{spec["max"]} elements but found {len(param)}.\')\n                            raise ValueError\n                        if \'struct\' in spec:\n                            spec = {k: spec[\'struct\'] for k in range(len(param))}\n                            config[attr] = self.verify_config(spec,\n                                dict(enumerate(param)), name=path).values()\n                    else:\n                        log.error(f\'Parameter "{path}" expected to be of type \'\n                            f\'"list" but found "{type(param).__name__}".\')\n                        raise TypeError\n                else:\n                    self.verify_param(path, spec, param)\n            else:\n                config[attr] = self.verify_config(spec, param, name=path)\n        \n        return config\n\n    \n    @classmethod\n    def verify_param(self, name, spec, param):\n        \'\'\'validates a single config parameter against a specification\n\n        Parameters\n        ----------\n        name: str\n            Name of the attribute being checked; used in error handling.\n\n        spec: dict\n            A dict containing the attributes of the parameter.\n\n        param: int/float/str/bool\n            The config parameter being validated.\n        \'\'\'\n        types = [self.types[t] for t in spec[\'type\'].split(\',\')]\n\n        if type(param) not in types:\n            types = \'", "\'.join(spec[\'type\'].split(\',\'))\n            log.error(f\'Parameter "{name}" expected to be of type "\'\n                f\'{types}" but found "{type(param).__name__}".\')\n            raise TypeError\n\n        if (\'options\' in spec and len(spec[\'options\']) \n                and param not in spec[\'options\']):\n            options = \', \'.join([f\'"{str(opt)}"\' for opt in spec[\'options\']])\n            log.error(f\'Parameter "{name}" expected to be {options} \'\n                f\'but found "{param}".\')\n            raise ValueError\n\n        if \'exceptions\' in spec and param in spec[\'exceptions\']:\n            log.error(f\'Parameter "{name}" cannot be "{param}".\')\n            raise ValueError\n\n        if \'min\' in spec and param < spec[\'min\']:\n            log.error(f\'Parameter "{name}" expected to be greater than \'\n                f\'{spec["min"]} but found {name}.\')\n            raise ValueError\n\n        if \'max\' in spec and param > spec[\'max\']:\n            log.error(f\'Parameter "{name}" expected to be less than \'\n                f\'{spec["max"]} but found {param}.\')\n            raise ValueError\n\n        if \'regex\' in spec and not re.search(spec[\'regex\'], param):\n            log.error(f\'Parameter "{name}" expected to match pattern \'\n                f\'{spec["regex"]} but found "{param}".\')\n            raise ValueError\n\n        if \'file\' in spec:\n            if spec[\'file\'] == \'exists\' and not FilesysUtil.file_exists(param):\n                log.error(f\'Parameter "{name}" expected to be an existing file \'\n                    \'but file could not be found.\')\n                raise ValueError\n            elif spec[\'file\'] == \'readable\' and not FilesysUtil.file_readable(param):\n                log.error(f\'Parameter "{name}" expected to be an readable file \'\n                    \'but file could not be read.\')\n                raise ValueError\n            elif spec[\'file\'] == \'writable\' and not FilesysUtil.file_writable(param):\n                log.error(f\'Parameter "{name}" expected to be an writable file \'\n                    \'but file could not be written to.\')\n                raise ValueError\n')
    __stickytape_write_module('icarus/util/filesys.py', "\nimport os\nimport sys\nimport tempfile\nimport subprocess\n\nclass FilesysUtil:\n    @classmethod\n    def file_readable(self, filepath):\n        'check that file can be read'\n        return os.access(filepath, os.R_OK)\n\n\n    @classmethod\n    def file_exists(self, filepath):\n        'check that file exists'\n        return os.path.exists(filepath)\n    \n\n    @classmethod\n    def file_writable(self, filepath):\n        'check that file can be written to'\n        if self.file_exists(filepath):\n            if os.path.isfile(filepath):\n                return os.access(filepath, os.W_OK)\n            else:\n                return False \n        \n        pdir = os.path.dirname(filepath)\n        if not pdir: \n            pdir = '.'\n        return os.access(pdir, os.W_OK)\n\n    \n    @classmethod\n    def delete_file(self, filepath):\n        'delete a file'\n        os.remove(filepath)\n\n\n    @classmethod\n    def create_tempfile(self, suffix=None, delete=True):\n        'create a temporary file'\n        return tempfile.NamedTemporaryFile(suffix=suffix, delete=delete)\n\n\n    @classmethod\n    def format_xml(self, source, target=None):\n        'format an xml file'\n        if target is None:\n            targetfile = self.create_tempfile(suffix='xml', delete=False)\n            target = targetfile.name\n            targetfile.close()\n            subprocess.run(f'xmllint --format {source} > {target}', shell=True)\n            subprocess.run(('mv', target, source), shell=False)\n        else:\n            subprocess.run(f'xmllint --format {source} > {target}', shell=True)\n\n\n    @classmethod\n    def compress_gz(self, source, target=None):\n        'decompress a gz file'\n        if target is None:\n            subprocess.run(('gzip', source), shell=False)\n            return source + '.gz'\n\n    @classmethod\n    def decompress_gz(self, source, target=None):\n        'decompress a gz file'\n        if target is None:\n            targetfile = self.create_tempfile(\n                suffix=source.split('.')[-2], delete=False)\n            target = targetfile.name\n            targetfile.close()\n        subprocess.run(f'gunzip --stdout {source} > {target}', shell=True)\n        return target\n\n    @classmethod\n    def package_resource(self, package, resource):\n        'get filepath of a package file'\n        try:\n            module = os.path.dirname(sys.modules[package].__file__)\n            return os.path.join(module, resource)\n        except:\n            return None")
    
    import os
    import logging as log
    from argparse import ArgumentParser
    
    from icarus.generate.population.population import Population
    from icarus.util.config import ConfigUtil
    from icarus.util.sqlite import SqliteUtil
    
    parser = ArgumentParser()
    parser.add_argument('--folder', type=str, dest='folder', default='.')
    parser.add_argument('--log', type=str, dest='log', default=None)
    parser.add_argument('--level', type=str, dest='level', default='info',
        choices=('notset', 'debug', 'info', 'warning', 'error', 'critical'))
    parser.add_argument('--replace', dest='replace', action='store_true', default=False)
    args = parser.parse_args()
    
    handlers = []
    handlers.append(log.StreamHandler())
    if args.log is not None:
        handlers.append(log.FileHandler(args.log, 'w'))
    log.basicConfig(
        format='%(asctime)s %(levelname)s %(filename)s:%(lineno)s %(message)s',
        level=getattr(log, args.level.upper()),
        handlers=handlers)
    
    path = lambda x: os.path.abspath(os.path.join(args.folder, x))
    home = path('')
    config = ConfigUtil.load_config(path('config.json'))
    
    log.info('Running population generation tool.')
    log.info(f'Loading run data from {home}.')
    
    database = SqliteUtil(path('database.db'))
    population = Population(database)
    
    if not population.ready():
        log.warning('Dependent data not parsed or generated.')
        log.warning('Population generation dependencies include ABM, parcel and '
            'region parsing; check that these are already run.')
        exit(1)
    elif population.complete():
        log.warning('Population already generated. Would you like to replace it? [Y/n]')
        if input().lower() not in ('y', 'yes', 'yeet'):
            log.info('User chose to keep existing population; exiting generation tool.')
            exit()
    
    try:
        log.info('Starting population generation.')
        population.generate()
    except:
        log.exception('Critical error while generating population; '
            'terminating process and exiting.')
        exit(1)
    
    database.close()